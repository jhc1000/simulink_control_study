close all;
clear all;
clc;

% 전체 경로 추가
context();

self.robot_name = "wlar_2d";

self.model = wlar_model;
self.kinematics = wlar_kinematics;
self.dynamics = dynamics;

self = self.model.init(self);
self = self.kinematics.init(self);
self = self.dynamics.init(self);

self.slope = [0.0, deg2rad(45), 0.0];

self.anchor.position(:,:,1) = [0.0; 0.0; 0.250];
self.anchor.position(:,:,2) = [0.0; -3.944; 0.250];

self.q_base = [0.0; deg2rad(0); 0.0];
self.p_base = [-2.0; -1.972; 0.48];

self.dot_q_base = [0.0; 0.0; 0.0];
self.dot_p_base = [0.0; 0.0; 0.0];

% self.q.hr = [deg2rad(90); deg2rad(-90); deg2rad(-90); deg2rad(90)];
% self.q.hr = [deg2rad(60); deg2rad(-60); deg2rad(-60); deg2rad(60)];
% self.q.hr = [deg2rad(30); deg2rad(-30); deg2rad(-30); deg2rad(30)];
% self.q.hr = [deg2rad(45); deg2rad(-45); deg2rad(-45); deg2rad(45)];
% self.q.hr = [deg2rad(1); deg2rad(-1); deg2rad(-1); deg2rad(1)];
self.q.hr = [deg2rad(0); deg2rad(-0); deg2rad(-0); deg2rad(0)];
self.q.hp = [deg2rad(-45); deg2rad(-45); deg2rad(45); deg2rad(45)];
% self.q.hp = [deg2rad(-90); deg2rad(-90); deg2rad(90); deg2rad(90)];
self.q.k = [deg2rad(90); deg2rad(90); deg2rad(-90); deg2rad(-90)];
self.q.asc = zeros(2,1);

%% Kinematics and Jacobians

self = self.kinematics.forward_kinematics(self, self.q_base, self.p_base);
self = self.kinematics.ascender_forward_kinematics(self, self.q_base, self.p_base);

self = self.kinematics.Jacobians(self, self.dot_q_base, self.dot_p_base);

%% Force Wrench Polytope
self = geometry_computation.compute_force_wrench_polytope(self);

%% GRF Estimation

%% Contact Wrench Cone
self = geometry_computation.compute_contact_wrench_polytope(self);

%% Ascender Wrench Polytope
self = geometry_computation.compute_ascender_wrench_polytope(self);

%% Total Force Polytope
for iteration=1:4
    if iteration == 1
        self.leg_force_polytope_total = [self.leg_force_wrench_polytope(:,1,iteration) self.leg_force_wrench_polytope(:,5,iteration) self.leg_force_wrench_polytope(:,3,iteration)];
    else
        self.leg_force_polytope_total = geometry_computation.minkowskiSum(self.leg_force_polytope_total,[self.leg_force_wrench_polytope(:,1,iteration) self.leg_force_wrench_polytope(:,5,iteration) self.leg_force_wrench_polytope(:,3,iteration)]);
    end
end

% for i=1:2
%     if i == 1
%         self.force_polytope_total = geometry_computation.minkowskiSum(self.leg_force_polytope_total, self.ascender_polytope_total(:,:,i));
%     else
%         self.force_polytope_total = geometry_computation.minkowskiSum(self.force_polytope_total, self.ascender_polytope_total(:,:,i));
%     end
% end

% Compute the convex hull of the Minkowski sum
self.leg_force_polytope_total_convhull = Polyhedron(self.leg_force_polytope_total);

% Plot the result
% figure;
% trisurf(self.leg_force_polytope_total_convhull, self.leg_force_polytope_total(:,1),self.leg_force_polytope_total(:,2),self.leg_force_polytope_total(:,3), 'FaceColor', 'green');
% xlabel("F_x [N]");ylabel("\tau_y [Nm]");zlabel("F_z [N]");
% title('Convex Hull of Total Force Polytope');
% axis equal;

%% Total Friction Polytope
for iteration=1:4
    if iteration == 1
        self.leg_friction_polytope_total = [self.leg_contact_wrench_polytope(:,1,iteration) self.leg_contact_wrench_polytope(:,2,iteration) self.leg_contact_wrench_polytope(:,3,iteration)];
    else
        self.leg_friction_polytope_total = geometry_computation.minkowskiSum(self.leg_friction_polytope_total,[self.leg_contact_wrench_polytope(:,1,iteration) self.leg_contact_wrench_polytope(:,2,iteration) self.leg_contact_wrench_polytope(:,3,iteration)]);
    end
end

% Compute the convex hull of the Minkowski sum
self.leg_friction_polytope_total_convhull = Polyhedron(self.leg_friction_polytope_total);


%% Total Feasible force Polytope
% self.leg_feasible_polytope_total = geometry_computation.minkowskiSum(self.leg_force_polytope_total,self.leg_friction_polytope_total);

% Create polyhedra from vertices
P1 = Polyhedron(self.leg_force_polytope_total);
P2 = Polyhedron(self.leg_friction_polytope_total);

% Compute the intersection of the two polyhedra
self.feasible_wrench_polytope_total_convhull = intersect(P1, P2);


%% Plotting
% plotting_tools.plot_robot_space(self);
% plotting_tools.plot_robot_base(self);
% plotting_tools.plot_force_polytopes(self);
% plotting_tools.plot_friction_polytopes(self);
plotting_tools.plot_fesible_polytopes(self);

%% Animation
% 새로운 figure 생성
fig = figure;
tiledlayout(1, 3);

% 첫 번째 서브플롯 설정
ax(1) = nexttile;
h1 = plot(self.leg_force_polytope_total_convhull, 'color', 'green', 'alpha', 0.5);
title(ax(1), 'Force Polytope');
xlabel(ax(1), "F_x [N]"); ylabel(ax(1), "\tau_y [Nm]"); zlabel(ax(1), "F_z [N]");
axis(ax(1), 'equal');
view(ax(1), 45, 30);

% 두 번째 서브플롯 설정
ax(2) = nexttile;
h2 = plot(self.leg_friction_polytope_total_convhull, 'color', 'red', 'alpha', 0.5);
title(ax(2), 'Friction Polytope');
xlabel(ax(2), "F_x [N]"); ylabel(ax(2), "\tau_y [Nm]"); zlabel(ax(2), "F_z [N]");
axis(ax(2), 'equal');
view(ax(2), 45, 30);

% 세 번째 서브플롯 설정
ax(3) = nexttile;
h3 = plot(self.feasible_wrench_polytope_total_convhull, 'color', 'blue', 'alpha', 0.5);
title(ax(3), 'Feasible Polytope');
xlabel(ax(3), "F_x [N]"); ylabel(ax(3), "\tau_y [Nm]"); zlabel(ax(3), "F_z [N]");
axis(ax(3), 'equal');
view(ax(3), 45, 30);

sgtitle('Feasible Wrench Polytope');

for iteration = 0:10:90
    % 로봇의 각도 업데이트
    self.q.hr = [deg2rad(iteration); deg2rad(-iteration); deg2rad(-iteration); deg2rad(iteration)];

    % 기구학 계산
    self = self.kinematics.forward_kinematics(self, self.q_base, self.p_base);
    self = self.kinematics.ascender_forward_kinematics(self, self.q_base, self.p_base);

    % 야코비안 계산
    self = self.kinematics.Jacobians(self, self.dot_q_base, self.dot_p_base);

    % 폴리토프 계산
    self = geometry_computation.compute_force_wrench_polytope(self);
    self = geometry_computation.compute_contact_wrench_polytope(self);

    for fi =1:4
        if fi == 1
            self.leg_force_polytope_total = [self.leg_force_wrench_polytope(:,1,fi) self.leg_force_wrench_polytope(:,5,fi) self.leg_force_wrench_polytope(:,3,fi)];
        else
            self.leg_force_polytope_total = geometry_computation.minkowskiSum(self.leg_force_polytope_total,[self.leg_force_wrench_polytope(:,1,fi) self.leg_force_wrench_polytope(:,5,fi) self.leg_force_wrench_polytope(:,3,fi)]);
        end
    end
    self.leg_force_polytope_total_convhull = Polyhedron(self.leg_force_polytope_total);

    for ci=1:4
        if ci == 1
            self.leg_friction_polytope_total = [self.leg_contact_wrench_polytope(:,1,ci) self.leg_contact_wrench_polytope(:,2,fi) self.leg_contact_wrench_polytope(:,3,fi)];
        else
            self.leg_friction_polytope_total = geometry_computation.minkowskiSum(self.leg_friction_polytope_total,[self.leg_contact_wrench_polytope(:,1,fi) self.leg_contact_wrench_polytope(:,2,fi) self.leg_contact_wrench_polytope(:,3,fi)]);
        end
    end
    self.leg_friction_polytope_total_convhull = Polyhedron(self.leg_friction_polytope_total);

    % 두 폴리토프의 교차 계산
    P1 = Polyhedron(self.leg_force_polytope_total);
    P2 = Polyhedron(self.leg_friction_polytope_total);

    % Compute the intersection of the two polyhedra
    self.feasible_wrench_polytope_total_convhull = intersect(P1, P2);

    % 기존 플롯을 지우고 새로운 폴리토프를 플로팅
    cla(ax(1)); % 첫 번째 서브플롯 클리어
    self.leg_force_polytope_total_convhull.plot('color', 'green', 'alpha', 0.5);
    title(ax(1), 'Force Polytope');
    xlabel(ax(1), "F_x [N]"); ylabel(ax(1), "\tau_y [Nm]"); zlabel(ax(1), "F_z [N]");
    axis(ax(1), 'equal');
    grid on;
    view(ax(1), 45, 30);

    cla(ax(2)); % 두 번째 서브플롯 클리어
    self.leg_friction_polytope_total_convhull.plot('color', 'red', 'alpha', 0.5);
    title(ax(2), 'Friction Polytope');
    xlabel(ax(2), "F_x [N]"); ylabel(ax(2), "\tau_y [Nm]"); zlabel(ax(2), "F_z [N]");
    axis(ax(2), 'equal');
    grid on;
    view(ax(2), 45, 30);

    cla(ax(3)); % 세 번째 서브플롯 클리어
    self.feasible_wrench_polytope_total_convhull.plot('color', 'blue', 'alpha', 0.5);
    title(ax(3), 'Feasible Polytope');
    xlabel(ax(3), "F_x [N]"); ylabel(ax(3), "\tau_y [Nm]"); zlabel(ax(3), "F_z [N]");
    axis(ax(3), 'equal');
    grid on;
    view(ax(3), 45, 30);

    sgtitle('Feasible Wrench Polytope');

    % 애니메이션 효과를 위한 일시 정지
    pause(0.5);
end


    
